"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from zendesk.types import BaseModel, UNSET_SENTINEL
from zendesk.utils import FieldMetadata, QueryParamMetadata


class SearchMacroRequestTypedDict(TypedDict):
    query: str
    r"""Query string used to find macros with matching titles"""
    include: NotRequired[str]
    r"""A sideload to include in the response. See [Sideloads](#sideloads-2)"""
    access: NotRequired[str]
    r"""Filter macros by access. Possible values are \"personal\", \"agents\", \"shared\", or \"account\". The \"agents\" value returns all personal macros for the account's agents and is only available to admins."""
    active: NotRequired[bool]
    r"""Filter by active macros if true or inactive macros if false"""
    category: NotRequired[int]
    r"""Filter macros by category"""
    group_id: NotRequired[int]
    r"""Filter macros by group"""
    only_viewable: NotRequired[bool]
    r"""If true, returns only macros that can be applied to tickets. If false, returns all macros the current user can manage. Default is false"""
    sort_by: NotRequired[str]
    r"""Possible values are \"alphabetical\", \"created_at\", \"updated_at\", or \"position\". Defaults to alphabetical"""
    sort_order: NotRequired[str]
    r"""One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"""


class SearchMacroRequest(BaseModel):
    query: Annotated[
        str, FieldMetadata(query=QueryParamMetadata(style="form", explode=True))
    ]
    r"""Query string used to find macros with matching titles"""

    include: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A sideload to include in the response. See [Sideloads](#sideloads-2)"""

    access: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter macros by access. Possible values are \"personal\", \"agents\", \"shared\", or \"account\". The \"agents\" value returns all personal macros for the account's agents and is only available to admins."""

    active: Annotated[
        Optional[bool],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter by active macros if true or inactive macros if false"""

    category: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter macros by category"""

    group_id: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter macros by group"""

    only_viewable: Annotated[
        Optional[bool],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""If true, returns only macros that can be applied to tickets. If false, returns all macros the current user can manage. Default is false"""

    sort_by: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Possible values are \"alphabetical\", \"created_at\", \"updated_at\", or \"position\". Defaults to alphabetical"""

    sort_order: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "include",
                "access",
                "active",
                "category",
                "group_id",
                "only_viewable",
                "sort_by",
                "sort_order",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
